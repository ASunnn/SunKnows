# 类的加载

一个类从被加载到虚拟机内存中，到被卸载出内存，这个声明周期有7个流程

* 加载
* 连接
    * 验证
    * 准备
    * 解析
* 初始化
* 使用
* 卸载

## 类初始化的时机

虚拟机规范曰：**有且仅有**5种场景会触发类的初始化

#### 1

遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，若类没有过初始化，就需要先触发它的初始化

通俗点说就是，使用*new Xxxx()*，读取或者设置类的静态字段，或者调用类的静态方法的时候，就会触发初始化

#### 2

使用*reflect*包对类进行反射调用的时候

#### 3

初始化类的时候，如果它爹还没初始化，就要先触发对其父类的初始化

#### 4

虚拟机启动时，*main()*方法所在的类需要先初始化

#### 5

*这条不懂，照抄书上的了*

使用jkd7的动态语言支持时，若一个*java.lang.invoke.MethodHandler*实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法举兵，并且这方法句柄所对应的类没有过初始化，就需要先触发它的初始化

# 类加载过程

## 加载

这个阶段，虚拟机需要完成3件事：

* 通过一个类的全限定名来获取定义此类的二进制字节流
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
* 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口

看看第一条：

虚拟机规范只说了通过类的全限定名来获取字节流，没说从哪里获取，因此可以在这上面做出各种花样。比如经常用的war，动态代理，还有jsp等

类的加载过程由类加载器去完成，下面有一节说这个

加载阶段完成后，外部的二进制字节流就转化为方法区的数据存储下来，同时生成了一个代表这个类的Class对象，这个对象将作为方法区这个类的各种数据的访问入口

> 加载阶段和连接阶段的一些流程交叉在一起了，即加载阶段没完成，连接阶段可能已经开始了。毕竟不验证解析不能放到虚拟机内存中

## 验证

连接阶段的第一步。主要是确保字节流包含的信息符合虚拟机要求，并且不会危害虚拟机

验证主要分为四阶段

#### 文件格式验证

主要验证字节流是否符合Class文件格式规范，并且能被当前版本虚拟机处理

这个阶段主要保证输入的字节流能正确的解析，格式符合

比如：

* 魔数
* 版本号是否在虚拟机处理范围内
* 常量池中是否有不被支持的常量类型

**这个阶段的验证是基于二进制字节流进行的，通过这个阶段之后字节流会进入内存方法去中存储，也就是说之后的阶段全部是基于方法区进行的，不会直接操作字节流**

#### 元数据验证

对字节码描述的信息进行语义分析，保证符合Java语言规范的要求

比如：

* 是否有合适的父类
* 不是抽象类的话有没有实现了父类or接口中要求实现的所有方法
* 类中的字段、方法与父类是否产生矛盾

#### 字节码验证

主要通过对数据流、控制流分析，确定代码语义是合法、符合逻辑的

简单说，前一个阶段是对类、数据类型等做校验，这个阶段对类的方法体进行校验，保证方法在运行时不会乱来，比如：

* 保证操作数栈的数据类型与指令代码序列能配合工作
* 保证跳转指令不会跳到方法体之外
* 保证方法中类型转换是有效的

#### 符号引用验证

这个阶段发生在虚拟机将符号引用转化为直接引用的时候（这个动作在解析阶段发生），主要检测类自身以外的信息进行校验，比如：

* 符号引用中通过字符串描述的全限定名是否能找到对应类
* 指定类中是否存在符合方法的字段描述符
* 符号引用中的类、字段方法的可见性，是否可以被当前类访问

## 准备

准备阶段是正式为类变量分配内存并且设置类变量初始值的阶段，这些变量使用的内存都实在方法区中分配的

上一句的类变量和方法区其实已经点名了static变量——这个阶段是给static变量分配内存

初始值呢？

有两种情况，一种是比如*static int v = 114514*，那么这个阶段v的值是0，拓展到全体就是初始为该数据类型的零值（比如引用类型就是null）

第二种情况是*static final int v = 114514*，这种情况编译时就会给v生成ConstantValue属性，准备阶段就会给v赋值114514而不是零值了

## 解析

这个阶段是虚拟机将常量池的符号引用替换为直接引用的过程

* 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要在用的时候能不产生歧义的定位到目标即可

* 直接引用：直接指向目标的指针、相对偏移量or能间接定位到目标的句柄

## 初始化

这个阶段是类加载的最后一步，真正开始执行类定义里的Java代码

简单来说初始化阶段是执行类构造器\<clinit>()的过程

\<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句，合并之后产生的，语句顺序直接根据类代码中各个代码的定义顺序。

这个方法和类的构造方法不是一个东西。

同时，虚拟机保证一个类的\<clinit>()只会被进入一次，即在多线程环境下，多个线程同时初始化一个类，只能有一个线程执行\<clinit>()

执行完这些之后，像上上阶段提到的赋零值的类变量就会被赋值为代码定义的值了（如果有的话）

> 类加载中，加载阶段是通过类加载器，中间的连接阶段都是只能由虚拟机进行，而初始化阶段执行Java代码

# 类加载器

之前说，类的加载过程由类加载器去完成。类加载器就是负责把Class加载到虚拟机中，而虚拟机规范并没有对这个做出什么限制，因此衍生出了许许多多各式各样的类加载器和类加载方式

类加载器起到的作用远不止实现类的加载动作

## 类和类加载器

对于任意一个类，都由加载它的类加载器和自己本身确定它在JVM中的唯一性。或者说，比较俩类是否相等，出了它们是同一个类还不行，还必须是由同一个类加载器加载的。每一个类加载器，都有一个独立的类名称空间

类Class对象的*equals()*方法，或者是*instanceof*关键字都是依靠这个关系来得出是否相等的结果

## 双亲委派模型

#### 类的等级加载机制

类加载器在加载类的时候有这样一个规则：当一个加载器需要加载一个类时，它会先把这个加载委托给父类加载器去完成。父类加载器接收到委托后也会先请求它的父类，每一个层次都如此。因此这个请求最终会传递到顶级的类加载器中。当父类表示无法加载的时候，子类才会尝试自己去加载

使用这种机制有一个好处就是Java类随着类加载器一起具备了一种带有优先级的层次关系。比如Object类加载时，最终会委托给顶级的加载器去加载它，因此Object类在各个加载器环境中都是同一个类。若没有使用这种机制的话，各个加载器加载自己的Object类，会导致程序一片混乱

#### 顶级的类加载器

JVM有三层顶级的类加载器

* Bootstrap ClassLoader

    启动加载器。这个加载器主要加载JVM自身工作需要的类，是由JVM自己控制的，也无法被用户访问。它是由C++实现的，因此也不怎么遵守加载机制，它既没有父加载器，也没有子加载器。负责加载<JAVA_HOME>/lib目录。

* ExtClassLoader

    拓展类加载器。这个加载器是JVM自身的一部分。可以被用户直接使用。负责加载<JAVA_HOME>/lib/ext目录。

* AppClassLoader

    这个加载器的父类是ExtClassLoader，它负责加载ClassPath上所制定的类库。用户也可以直接使用它。如果程序中没有自定义过类加载器，他就是默认的类加载。

#### 双亲委派模型

我们实现自己的类加载器的时候，父加载器总是AppClassLoader。于是，类加载器之间的关系一般是这样的：

![](PIC/类加载器的双亲委派模型.jpg)

再加上先前说过的类的等级加载机制。这就是类加载器的双亲委派模型（顺带一提，个人觉得Bootstrap ClassLoader不能放在里面

