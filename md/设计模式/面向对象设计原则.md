# 单一职责原则

> 就一个类而言，应该仅有一个引起它变化的原因

单一职责原则的意义其实很简单，一个类（或者是一个方法）承担的职责不应该太多，正常情况下，一个类or方法应该仅仅只负责一个功能
<!-- 
## 为什么

刚开始敲代码的时候，一个函数里常常混杂着五花八门的功能，这样使得函数冗长又难以阅读。同时，这样的函数难以复用。如果程序出bug，很难定位到准确的语句

假设一个函数α包含了ABC三个功能模块
另外一个函数β需要C、D和E功能，这时候又得重新写一遍。再然后γ函数需要A、C两个功能

这时候C已经被写3次了。

同样，如果一个函数有A、B、C、D、E五个功能模块在里头，如果这个函数出了bug，具体定位到哪一个地方是很麻烦的事（如果是C出bug的话恭喜你还要再改3次

## 怎么做

个人觉得单一职责原则是最简单但是又是最难做到的一个原则。

在敲代码之前，你需要想到这个流程有几个功能，然后划分到相应的函数里。确保一个函数只做一件事

当然，更多时候自己都是过后才发现需要重用，才把代码抽出来成为单独函数 -->

# 开放-封闭原则

> 软件尸体（类、模块、函数等）应该对拓展开放，但是对修改关闭

甲ba方ba天天改需求是很正常的事。当我们需要修改代码的时候，应该尽量保持系统框架的稳定。一个保持良好的开闭原则的系统，是很易于拓展和维护的（虽然我没试过

开闭原则的核心是抽象化，在我看来即面向接口编程。

现在主流的oop语言都提供了诸如抽象类这种的支持。我们可以先定义系统业务的抽象层，然后再通过具体的实现类去完成它。

如果这时候有新的需求需要我们修改系统业务，我们无需对原有的实现或者是抽象层进行改动，只需要增加新的实现类即可

当然，绝对的开闭原则是不可能的

# 依赖倒转原则

> 高层模块不应该依赖底层模块。两个都应该依赖抽象。

>抽象不应该依赖细节。细节应该依赖抽象。

这个原则其实就一句话，面向接口编程。

系统业务不论是高层模块还是底层模块，都应该抽象为接口，模块之间的交互使用接口进行。这样模块之间的更换或者是拓展都会变得非常容易。

# 里氏代换原则

> 子类型必须能够替换掉它们的父类型

在程序中，把一个父类对象替换成它的子类对象，程序将不会产生任何错误，反过来则不行（参考OOP的多态

正是由于这种特性，开闭原则和依赖倒转原则才成为了可能。

由于子类型的可替换性，用父类型（接口）定义的模块，在无需修改其他的情况下就能替换或者拓展。

# 迪米特法则

> 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的互相作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。

这个法则的思想就是强调类之间的松耦合

简单来说，一个类不应当和陌生人说话，只和朋友沟通，朋友比如：

* 当前对象本身(this)；
* 以参数形式传入到当前对象方法中的对象；
* 当前对象的成员对象；
* 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
* 当前对象所创建的对象

