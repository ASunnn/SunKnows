# 冒泡排序

不会的请重新学习C语言

# 简单选择排序

不会的请重新学习C语言

# 直接插入排序

不会的请重新学习C语言

# 希尔排序

直接插入排序在数据基本有序或者记录较少的时候，效率较高，但是这两种条件都有些极端。

因此可以考虑把记录弄成基本有序：小的关键字基本在前，大的关键字基本在后。

希尔排序可以看作是直接插入排序的升级版，只不过它是以一定的增量作为基础，将相隔一个增量的数组成一个子序列，进行跳跃式移动。一轮过后，记录就是大致有序的了，再将增量缩小，再次排序。当增量减为1时就是直接插入排序了，但这时记录已经是基本有序的，基本上不需要太多操作了

# 堆排序

> 堆：一个完全二叉树。大顶堆：每个节点的值都大于等于它的孩子。小顶堆：反过来。

堆排其实就是利用堆进行排序。也能看作简单选择排序的升级版。

首先把待排记录组成一个大（小）顶堆。这时候，堆顶的值就是所有记录中最大（小）的。把堆顶移走（和末尾元素交换），剩下n-1个记录重新组成堆，再移走堆顶。

这样循环，直到所有记录都排好序。

# 归并排序（2路归并）

归并排序的主要思想就是把待排的记录分开为两份，分开的记录再分开，直到拆分成长度为1为止。

这时候可以把长度只有1的记录当成是有序的。

然后两两合并，合并的时候因为两个子序列都是有序的，因此可以很方便的合并为一个有序的序列。这样重复两两合并，直到合并为原来的长度。

合并回去之后的序列就是有序的了。

# 快排

快排可以看作时冒泡排序的升级。

它的核心思想是，通过一轮排序将序列记录分割成独立两部分，一部分的关键字都要比另一部分要小。然后下一轮，再用同样的做法，对这两部分分别进行排序，这样重复，整个序列变成有序。