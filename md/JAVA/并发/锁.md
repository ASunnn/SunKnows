# 

## 公平锁

当有多个线程申请锁的时候，按照线程的申请顺序来获取锁

公平锁的好处是每个线程一定会拿到锁，不存在饥饿现象。坏处就在于吞吐量差一些

## 非公平锁

平时比较常见的锁，申请锁的线程都是以抢占的方式来获取锁的

好处和坏处和公平锁正好相反。非公平锁的吞吐量高，但是可能会造成饥饿现象

*synchronized*就是非公平锁

## 共享锁

共享锁允许多个线程获取锁

## 排他锁

只允许一个线程获取锁

一般来说，一个对象加上共享锁之后，其他线程也能往它上边继续加共享锁

到那时如果一个线程往对象加排他锁，其他线程既不能再加排他锁也不能加共享锁

*synchronized*和*Lock*都是排他锁

## 悲观锁

认为并发操作一定会发生冲突，进行操作的时候必须加锁完全排除其他线程的并发干扰

## 乐观锁

认为并发操作不一定会发生冲突，只是在做修改操作这些的时候会检查数据的正确性

CAS是乐观锁的典型实现

## 可重入锁

又叫递归锁。是指一个线程获取锁后，可以再次获取锁

这货可以一定程度上避免死锁

demo：

```java
    synchronized void methodA() {
        methodB();
    }

    synchronized void methodB() {
        System.out.println("Hello World");
    }
```
所以说*synchronized*也是可重入锁。如果是非重入锁的话，调用*methodB*就会出错

## 自旋锁

一个线程在获取锁失败的时候，不会立即阻塞，而是在原地忙等循环一段时间，试着等待锁释放

Java线程的挂起和恢复是比较耗时的（因为是映射到操作系统，要操作系统帮忙），因此如果遇到一些很快就释放的锁（比如*getter*和*setter*），线程阻塞再唤醒所消耗的资源比原地等待还高。在这里使用自旋能节省一些开销

当然原地自旋的线程还是要占用当前的CPU的

## 偏向锁

jdk6中*synchronized*锁优化的一种

偏向锁会记住获取它的线程。如果之后没有其他线程获取锁，那么获取过它的线程将不需要再次同步

当其他线程获取锁的时候，偏向锁就会结束

当只有单个线程的时候，这种锁和执行非同步方法的性能差不多

## 轻量级锁

jdk6中*synchronized*锁优化的一种

当其他线程获取锁的时候，偏向锁就会结束，膨胀为轻量级锁

轻量级锁的时候，线程是通过自旋去获取锁

## 重量级锁

jdk6中*synchronized*锁的一种状态

当*synchronized*处于轻量级锁时，如果自旋的线程获取锁失败，就会膨胀为重量级锁

重量级锁和一般的抢占式锁没有区别，这时候的锁同步效率最低

# synchronized


# Lock


